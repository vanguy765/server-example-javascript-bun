/**
 * Example of directly querying Supabase database schema using their API
 *
 * This approach doesn't require the Supabase CLI and works purely through
 * the Supabase JavaScript client.
 */
import { createClient } from "@supabase/supabase-js";
import * as fs from "fs";
import * as path from "path";

// Define output paths
const TYPES_OUTPUT = path.join(
  __dirname,
  "../../src/supabase/generated-api.types.ts"
);
const SCHEMAS_OUTPUT = path.join(
  __dirname,
  "../../src/supabase/generated-api.schemas.ts"
);

async function generateTypesFromSchema() {
  console.log("ðŸš€ Starting schema introspection via Supabase API...");

  // Initialize Supabase client with your credentials
  const supabaseUrl = process.env.SUPABASE_URL || "your-supabase-url";
  const supabaseKey = process.env.SUPABASE_ANON_KEY || "your-supabase-key";
  const supabase = createClient(supabaseUrl, supabaseKey);

  try {
    // Step 1: Query all tables in the public schema
    console.log("ðŸ“Š Querying tables in public schema...");
    const { data: tables, error: tablesError } = await supabase
      .from("information_schema.tables")
      .select("table_name")
      .eq("table_schema", "public")
      .not("table_name", "like", "pg_%") // Exclude PostgreSQL system tables
      .order("table_name");

    if (tablesError) {
      throw new Error(`Error fetching tables: ${tablesError.message}`);
    }

    console.log(
      `ðŸ“‹ Found ${tables.length} tables: ${tables
        .map((t) => t.table_name)
        .join(", ")}`
    );

    // Initialize the TypeScript type definitions
    let typesContent = `// Auto-generated TypeScript types from Supabase schema
// Generated on: ${new Date().toISOString()}

export type Database = {
  public: {
    Tables: {
`;

    let zodContent = `// Auto-generated Zod schemas from Supabase schema
// Generated on: ${new Date().toISOString()}

import { z } from 'zod';

`;

    // Process each table
    for (const table of tables) {
      const tableName = table.table_name;
      console.log(`ðŸ” Processing table: ${tableName}`);

      // Step 2: Get columns for the current table
      const { data: columns, error: columnsError } = await supabase
        .from("information_schema.columns")
        .select(
          `
          column_name,
          data_type,
          is_nullable,
          column_default,
          character_maximum_length,
          numeric_precision,
          numeric_scale
        `
        )
        .eq("table_schema", "public")
        .eq("table_name", tableName)
        .order("ordinal_position");

      if (columnsError) {
        throw new Error(
          `Error fetching columns for ${tableName}: ${columnsError.message}`
        );
      }

      // Step 3: Get primary key columns
      const { data: primaryKeys, error: pkError } = await supabase
        .from("information_schema.key_column_usage")
        .select("column_name")
        .eq("table_schema", "public")
        .eq("table_name", tableName)
        .eq("constraint_name", `${tableName}_pkey`);

      if (pkError) {
        console.warn(
          `Warning: Could not fetch primary keys for ${tableName}: ${pkError.message}`
        );
      }

      const primaryKeyColumns = primaryKeys?.map((pk) => pk.column_name) || [];

      // Generate TypeScript types for this table
      typesContent += `      ${tableName}: {\n`;

      // Row type (complete database row)
      typesContent += `        Row: {\n`;
      for (const column of columns) {
        const tsType = mapPostgreSQLToTypeScript(column);
        typesContent += `          ${column.column_name}: ${tsType};\n`;
      }
      typesContent += `        };\n`;

      // Insert type (for creating new rows)
      typesContent += `        Insert: {\n`;
      for (const column of columns) {
        const isGenerated = isAutoGenerated(column);
        const isRequired =
          !column.is_nullable.toLowerCase().includes("yes") && !isGenerated;
        const tsType = mapPostgreSQLToTypeScript(column);

        // Make auto-generated fields optional in Insert
        if (isGenerated) {
          typesContent += `          ${column.column_name}?: ${tsType};\n`;
        } else {
          typesContent += `          ${column.column_name}${
            isRequired ? "" : "?"
          }: ${tsType};\n`;
        }
      }
      typesContent += `        };\n`;

      // Update type (for updating existing rows)
      typesContent += `        Update: {\n`;
      for (const column of columns) {
        const tsType = mapPostgreSQLToTypeScript(column);
        // All fields optional in Update
        typesContent += `          ${column.column_name}?: ${tsType};\n`;
      }
      typesContent += `        };\n`;

      typesContent += `      };\n`;

      // Generate Zod schemas for this table
      zodContent += `// ${tableName} schemas\n`;

      // Base schema with all fields
      zodContent += `export const ${tableName}Schema = z.object({\n`;
      for (const column of columns) {
        const zodType = mapPostgreSQLToZod(column);
        zodContent += `  ${column.column_name}: ${zodType},\n`;
      }
      zodContent += `});\n\n`;

      // Insert schema (omit auto-generated fields)
      const generatedFields = columns
        .filter((col) => isAutoGenerated(col))
        .map((col) => col.column_name);

      if (generatedFields.length > 0) {
        zodContent += `export const ${tableName}InsertSchema = ${tableName}Schema.omit({\n`;
        for (const field of generatedFields) {
          zodContent += `  ${field}: true,\n`;
        }
        zodContent += `});\n\n`;
      } else {
        zodContent += `export const ${tableName}InsertSchema = ${tableName}Schema;\n\n`;
      }

      // Update schema (all fields optional)
      zodContent += `export const ${tableName}UpdateSchema = ${tableName}InsertSchema.partial();\n\n`;

      // Type exports
      zodContent += `// Type exports\n`;
      zodContent += `export type ${pascalCase(
        tableName
      )} = z.infer<typeof ${tableName}Schema>;\n`;
      zodContent += `export type ${pascalCase(
        tableName
      )}Insert = z.infer<typeof ${tableName}InsertSchema>;\n`;
      zodContent += `export type ${pascalCase(
        tableName
      )}Update = z.infer<typeof ${tableName}UpdateSchema>;\n\n`;
    }

    // Complete the TypeScript types
    typesContent += `    };\n`; // Close Tables

    // Add Functions section
    typesContent += `    Functions: {\n`;
    // You could query PostgreSQL functions here, but for simplicity we'll leave it empty
    typesContent += `      // Add function definitions here\n`;
    typesContent += `    };\n`; // Close Functions

    // Add Enums section
    typesContent += `    Enums: {\n`;
    // Query PostgreSQL enums
    const { data: enums, error: enumsError } = await supabase
      .from("pg_type")
      .select(
        `
        typname,
        pg_enum.enumlabel
      `
      )
      .eq("typtype", "e")
      .join("pg_enum", "pg_type.oid", "pg_enum.enumtypid")
      .order("typname");

    if (enumsError) {
      console.warn(`Warning: Could not fetch enums: ${enumsError.message}`);
    } else {
      // Group enum values by enum name
      const enumGroups = enums.reduce((acc, curr) => {
        const typname = curr.typname;
        if (!acc[typname]) {
          acc[typname] = [];
        }
        acc[typname].push(curr.enumlabel);
        return acc;
      }, {} as Record<string, string[]>);

      for (const [enumName, values] of Object.entries(enumGroups)) {
        typesContent += `      ${enumName}: ${values
          .map((v) => `"${v}"`)
          .join(" | ")};\n`;

        // Also add enum to Zod schemas
        zodContent += `export const ${enumName}Enum = z.enum([${values
          .map((v) => `"${v}"`)
          .join(", ")}]);\n`;
      }
    }
    typesContent += `    };\n`; // Close Enums

    typesContent += `  };\n`; // Close public
    typesContent += `};\n\n`; // Close Database

    // Add convenience type exports
    typesContent += `// Convenience exports\n`;
    for (const table of tables) {
      const tableName = table.table_name;
      const pascalName = pascalCase(tableName);
      typesContent += `export type ${pascalName} = Database['public']['Tables']['${tableName}']['Row'];\n`;
      typesContent += `export type ${pascalName}Insert = Database['public']['Tables']['${tableName}']['Insert'];\n`;
      typesContent += `export type ${pascalName}Update = Database['public']['Tables']['${tableName}']['Update'];\n`;
    }

    // Write output files
    fs.writeFileSync(TYPES_OUTPUT, typesContent);
    fs.writeFileSync(SCHEMAS_OUTPUT, zodContent);

    console.log(`âœ… Successfully generated types at ${TYPES_OUTPUT}`);
    console.log(`âœ… Successfully generated Zod schemas at ${SCHEMAS_OUTPUT}`);

    // Provide usage examples
    console.log("\nðŸ“š Here's how to use the generated files:\n");
    console.log("// Import types");
    console.log(
      `import { Database, Tenant } from '${path
        .relative(process.cwd(), TYPES_OUTPUT)
        .replace(/\\/g, "/")}';\n`
    );
    console.log("// Import schemas");
    console.log(
      `import { tenantSchema, tenantInsertSchema } from '${path
        .relative(process.cwd(), SCHEMAS_OUTPUT)
        .replace(/\\/g, "/")}';\n`
    );
  } catch (error) {
    console.error("âŒ Error generating types:", error);
  }
}

// Helper functions

// Convert PostgreSQL data type to TypeScript type
function mapPostgreSQLToTypeScript(column: {
  data_type: string;
  is_nullable: string;
  column_default?: string | null;
}): string {
  const isNullable = column.is_nullable.toLowerCase().includes("yes");
  const nullableSuffix = isNullable ? " | null" : "";

  switch (column.data_type.toLowerCase()) {
    case "integer":
    case "bigint":
    case "smallint":
    case "decimal":
    case "numeric":
    case "real":
    case "double precision":
      return `number${nullableSuffix}`;

    case "boolean":
      return `boolean${nullableSuffix}`;

    case "json":
    case "jsonb":
      return `unknown${nullableSuffix}`;

    case "timestamp without time zone":
    case "timestamp with time zone":
    case "date":
    case "time without time zone":
    case "time with time zone":
      return `string${nullableSuffix}`;

    case "character varying":
    case "text":
    case "uuid":
    case "varchar":
    case "char":
    default:
      return `string${nullableSuffix}`;
  }
}

// Convert PostgreSQL data type to Zod validator
function mapPostgreSQLToZod(column: {
  data_type: string;
  is_nullable: string;
  column_name: string;
  column_default?: string | null;
}): string {
  const isNullable = column.is_nullable.toLowerCase().includes("yes");
  let zodType: string;

  switch (column.data_type.toLowerCase()) {
    case "integer":
    case "bigint":
    case "smallint":
    case "decimal":
    case "numeric":
    case "real":
    case "double precision":
      zodType = "z.number()";
      if (
        column.column_name === "price" ||
        column.column_name.endsWith("_price")
      ) {
        zodType += '.nonnegative("Price must be non-negative")';
      }
      break;

    case "boolean":
      zodType = "z.boolean()";
      break;

    case "json":
    case "jsonb":
      zodType = "z.unknown()";
      break;

    case "timestamp without time zone":
    case "timestamp with time zone":
    case "date":
      zodType = "z.string().datetime()";
      break;

    case "uuid":
      zodType = "z.string().uuid()";
      break;

    case "character varying":
    case "text":
    case "varchar":
    case "char":
    default:
      zodType = "z.string()";

      // Add specific validations based on column names
      if (
        column.column_name === "email" ||
        column.column_name.endsWith("_email")
      ) {
        zodType += '.email("Invalid email format")';
      } else if (
        column.column_name === "url" ||
        column.column_name.endsWith("_url")
      ) {
        zodType += '.url("Invalid URL format")';
      } else if (
        column.column_name === "phone" ||
        column.column_name.endsWith("_phone")
      ) {
        zodType +=
          '.regex(/^\\+?[0-9]{10,15}$/, "Invalid phone number format")';
      }

      break;
  }

  // Make nullable if needed
  if (isNullable) {
    zodType += ".nullable()";
  }

  return zodType;
}

// Check if a column is likely auto-generated
function isAutoGenerated(column: {
  column_name: string;
  column_default?: string | null;
  data_type: string;
}): boolean {
  // Common auto-generated columns
  if (
    ["id", "created_at", "updated_at", "created_by", "updated_by"].includes(
      column.column_name
    )
  ) {
    return true;
  }

  // Check for auto-increment or UUID generation in default value
  if (column.column_default) {
    if (
      column.column_default.includes("nextval") ||
      column.column_default.includes("gen_random_uuid") ||
      column.column_default.includes("uuid_generate_v4") ||
      column.column_default.includes("now()")
    ) {
      return true;
    }
  }

  return false;
}

// Convert snake_case to PascalCase
function pascalCase(str: string): string {
  return str
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}

// Run the generator
generateTypesFromSchema().catch(console.error);
